function processProvincesAndBuildings() {
  var startTime = new Date();
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // Инициализация данных
    const { stateName, stateData, stateMetrics, workersCoefficient, averageSalary, corporateTax } = initializeStateData(ss);

    // Чтение данных
    const provincesData = readProvincesData(ss);
    const buildingTemplatesMap = readBuildingTemplates(ss);
    const resourcesData = readResourcesData(ss);
    const { resourceIndexMap, resourceStock, resourcePrices, resourceSupplyTotal, resourceDemand } = resourcesData;

    // Чтение и обнуление атрибутов государства
    const attributesRange = ss.getRangeByName('Переменные_Атрибуты');
    const attributesJSON = attributesRange.getValue();
    let attributesData = attributesJSON ? JSON.parse(attributesJSON) : {};
    resetStateAttributes(attributesData);

    // Фильтрация провинций
    const targetProvinces = provincesData.filter(province => province && province.owner === stateName);
    const otherProvinces = provincesData.filter(province => province && province.owner !== stateName);

    // Очистка спроса и предложения на складе товаров
    const demandRange = ss.getRangeByName('СкладТоваров_Спрос');
    const supplyRange = ss.getRangeByName('СкладТоваров_Предложение');
    demandRange.clearContent();
    supplyRange.clearContent();

    // Инициализация журнала событий
    const eventLog = [];

    // Обработка провинций, принадлежащих текущему государству
    targetProvinces.forEach(province => {
      processProvince(province, stateName, stateData, stateMetrics, buildingTemplatesMap, resourceIndexMap, resourceStock, resourcePrices, averageSalary, corporateTax, eventLog, attributesData, resourceDemand, resourceSupplyTotal);
    });

    // Обработка провинций других государств
    processOtherProvinces(otherProvinces, stateName, stateMetrics, eventLog);

    // Применение лимитов построек на уровне государства и провинций
    enforceBuildingLimits(buildingTemplatesMap, targetProvinces, stateName, eventLog);
    enforceProvinceBuildingLimits(buildingTemplatesMap, provincesData, stateName, eventLog);
	
	// Ограничение атрибутов государства
    enforceStateAttributeLimits(attributesData, eventLog);

    // Запись обновленных атрибутов
    attributesRange.setValue(JSON.stringify(attributesData));

    // Обновление складов и записей в таблицу
    updateSpreadsheet(ss, provincesData, resourceStock, resourceSupplyTotal, resourceDemand, eventLog, stateMetrics);

    logResult("processProvincesAndBuildings", "", (new Date() - startTime) / 1000, "Успешно");
  } catch (e) {
    logResult("processProvincesAndBuildings", e.toString(), (new Date() - startTime) / 1000, "Ошибка");
  }
}

// Инициализация данных государства.
function initializeStateData(ss) {
  // Получаем JSON-строку из диапазона 'Переменные_Ссылки'
  const linksJSON = ss.getRangeByName('Переменные_Ссылки').getValue();
  let stateName = 'Неизвестно'; // Значение по умолчанию

  if (linksJSON) {
    try {
      const links = JSON.parse(linksJSON);
      stateName = links.stateName || 'Неизвестно'; // Извлекаем stateName
    } catch (e) {
      Logger.log(`Ошибка парсинга JSON из 'Переменные_Ссылки': ${e}`);
    }
  }
  
  const stateModifiersJSON = ss.getRangeByName('Переменные_МодификаторыГосударства').getValue();
  const stateModifiers = stateModifiersJSON ? JSON.parse(stateModifiersJSON) : {};

  const workersCoefficient = stateModifiers.workers_coefficient || 0;
  const averageSalary = stateModifiers.average_salary || 0;
  const corporateTax = stateModifiers.corporate_tax || 0;
  const stateStability = stateModifiers.social_stability || 0;

  const stateCultures = readDataFromRange('ПеременныеСписки_Культуры');
  const stateReligions = readDataFromRange('ПеременныеСписки_Религии');
  const stateRaces = readDataFromRange('ПеременныеСписки_Расы');
  const stateTechnologies = readStateTechnologiesGeneral('ПеременныеСписки_Технологии');
  const stateLaws = readStateLawsGeneral('ПеременныеСписки_Законы');
  const stateGovernmentType = ss.getRangeByName('Переменные_ТипПравительства').getValue();

  const stateData = {
    cultures: stateCultures,
    religions: stateReligions,
    races: stateRaces,
    technologies: stateTechnologies,
    laws: stateLaws,
    government_type: stateGovernmentType,
    stability: stateStability,
    ...stateModifiers
  };

  const stateMetrics = {
    corporate_tax_income: 0,
    state_buildings_income: 0,
    state_buildings_expenses: 0,
    workers_available: 0,
    workers_occupied: 0,
    workers_required: 0,
    agricultural_land_total: 0,
    agricultural_land_used: 0,
    agricultural_land_free: 0,
    state_buildings_income_foreign: 0,
    state_buildings_expenses_foreign: 0
  };

  return { stateName, stateData, stateMetrics, workersCoefficient, averageSalary, corporateTax };
}

// Чтение данных провинций.
function readProvincesData(ss) {
  const provincesRange = ss.getRangeByName('Провинции_ОсновнаяИнформация');
  const provincesValues = provincesRange.getValues();
  const provincesData = provincesValues.map(row => {
    if (row[0]) {
      try {
        return JSON.parse(row[0]);
      } catch (e) {
        Logger.log(`Ошибка парсинга провинции: ${e}`);
        return null;
      }
    } else {
      return null;
    }
  });
  return provincesData;
}

// Чтение данных ресурсов.
function readResourcesData(ss) {
  const resourceListRange = ss.getRangeByName('СкладТоваров_СписокРесурсов');
  const resourceList = resourceListRange.getValues().flat();
  const resourcePricesRange = ss.getRangeByName('СкладТоваров_Цены');
  const resourcePrices = resourcePricesRange.getValues().flat();
  const resourceStockRange = ss.getRangeByName('СкладТоваров_Накоплено');
  const resourceStock = resourceStockRange.getValues().flat();
  const resourceSupplyRange = ss.getRangeByName('СкладТоваров_Предложение');
  const resourceSupply = resourceSupplyRange.getValues().flat();

  const resourceIndexMap = {};
  resourceList.forEach((resource, index) => {
    resourceIndexMap[resource] = index;
  });

  let resourceDemand = Array(resourceList.length).fill(0);
  let resourceSupplyTotal = Array(resourceList.length).fill(0);

  return { resourceList, resourcePrices, resourceStock, resourceSupply, resourceIndexMap, resourceDemand, resourceSupplyTotal };
}

function resetStateAttributes(attributesData) {
  const stateAttributesResetMap = {
    'science_points': true,
    'religion_points': false,
    'culture_points': false
    // Добавьте другие атрибуты по необходимости
  };

  for (const attributeKey in stateAttributesResetMap) {
    if (stateAttributesResetMap[attributeKey]) {
      attributesData[attributeKey] = 0;
    }
  }
}

// Обработка одной провинции.
function processProvince(province, stateName, stateData, stateMetrics, buildingTemplatesMap, resourceIndexMap, resourceStock, resourcePrices, averageSalary, corporateTax, eventLog, attributesData, resourceDemand, resourceSupplyTotal) {
  // Локальные переменные и инициализация
  let provinceMessages = [];
  province.available_workers = Math.floor(province.population * stateData.workers_coefficient);
  province.occupied_workers = 0;
  stateMetrics.workers_available += province.available_workers;

  // Агрокультурные земли
  let freeAgriculturalLand = province.agricultural_land || 0;
  let usedAgriculturalLand = 0;
  stateMetrics.agricultural_land_total += province.agricultural_land || 0;

  // Атрибуты провинции
  let provinceAttributes = province.province_attributes || {};
  resetProvinceAttributes(provinceAttributes);

  // Обнуляем доходы и расходы построек
  if (province.buildings && province.buildings.length > 0) {
    province.buildings.forEach(building => {
      resetBuilding(building);
      const buildingTemplate = buildingTemplatesMap[building.name];
      if (!buildingTemplate) {
      building.status = 'Неактивная'; // Устанавливаем статус "Неактивная" для построек без шаблона
      eventLog.push([`Шаблон для постройки "${building.name}" в провинции "${province.province_id}" не найден. Постройка получила статус "Неактивная" и будет снесена через некоторое количество ходов.`, 'Сообщить Администрации']);
      return; // Прерываем обработку этой постройки
      }

      // Применение модификаторов
      const modifiers = applyBuildingModifiers(buildingTemplate, stateData);
      const productionEfficiency = modifiers.productionEfficiency;
      const extractionCoefficient = modifiers.extractionCoefficient;
      const consumptionEfficiency = modifiers.consumptionEfficiency;

      // Проверка критериев
      if (!checkBuildingCriteria(buildingTemplate, province, stateData, stateName, building, provinceMessages, attributesData)) return;

      // Проверка и назначение рабочих
      if (!assignWorkers(buildingTemplate, province, stateMetrics, averageSalary, building, provinceMessages)) return;

      // Проверка агрокультурных земель
      const requiredAgriculturalLand = buildingTemplate.required_agricultural_land || 0;
      if (freeAgriculturalLand < requiredAgriculturalLand) {
        building.status = 'Неактивная';
        provinceMessages.push(`Недостаточно агрокультурных земель для постройки "${building.name}" в провинции "${province.province_id}". Необходимо ${requiredAgriculturalLand}, доступно ${freeAgriculturalLand}. Постройка получит статус "Неактивная".`);
        return;
      }
      usedAgriculturalLand += requiredAgriculturalLand;
      freeAgriculturalLand -= requiredAgriculturalLand;

      // Обработка ресурсов
      if (!processBuildingResources(building, buildingTemplate, province, resourceIndexMap, resourceStock, resourcePrices, consumptionEfficiency, provinceMessages, resourceDemand, resourceSupplyTotal)) return;

      // Обработка производства ресурсов
      processResourceProduction(building, buildingTemplate, resourceIndexMap, resourceStock, stateMetrics, resourcePrices, productionEfficiency, resourceDemand, resourceSupplyTotal);

      // Обработка корпоративного налога
      processCorporateTax(building, stateName, corporateTax, stateMetrics);

      // Обработка атрибутов построек
      updateAttributes(building, buildingTemplate, provinceAttributes, attributesData);

      // Обработка resource_extraction
      if (building.status === 'Активная' && buildingTemplate.resource_extraction) {
        processResourceExtraction(building, buildingTemplate, province, resourceIndexMap, resourceStock, resourcePrices, extractionCoefficient, provinceMessages, resourceDemand, resourceSupplyTotal);
      }

      // Обновление метрик
      if (building.building_owner === stateName) {
        stateMetrics.state_buildings_income += building.incomes;
        stateMetrics.state_buildings_expenses += building.expenses;
      }
    });
  }

  // Обработка самоуничтожения построек
  handleSelfDestruction(province, eventLog);

  // Ограничение атрибутов провинции
  enforceProvinceAttributeLimits([province], stateName, eventLog);

  // Обновление агрокультурных земель
  province.agricultural_land_used = usedAgriculturalLand;
  province.agricultural_land_free = freeAgriculturalLand;
  stateMetrics.agricultural_land_used += usedAgriculturalLand;
  stateMetrics.agricultural_land_free += freeAgriculturalLand;

  // Логирование сообщений
  if (provinceMessages.length > 0) {
    eventLog.push([`Провинция "${province.province_id}": ${provinceMessages.join('; ')}`, 'Уведомление']);
  }
}

// Обработка других провинций
function processOtherProvinces(otherProvinces, stateName, stateMetrics, eventLog) {
  otherProvinces.forEach(province => {
    if (!province) return;

    if (province.buildings && province.buildings.length > 0) {
      province.buildings.forEach(building => {
        if (building.building_owner === stateName && building.status === 'Активная') {
          stateMetrics.state_buildings_income_foreign += building.incomes || 0;
          stateMetrics.state_buildings_expenses_foreign += building.expenses || 0;
        }
      });
    }
  });
}

// Обновление данных в таблице и журнале событий.
function updateSpreadsheet(ss, provincesData, resourceStock, resourceSupplyTotal, resourceDemand, eventLog, stateMetrics) {
  // Обновление складов ресурсов
  const resourceStockRange = ss.getRangeByName('СкладТоваров_Накоплено');
  resourceStockRange.setValues(resourceStock.map(value => [value]));
  const supplyRange = ss.getRangeByName('СкладТоваров_Предложение');
  supplyRange.setValues(resourceSupplyTotal.map(value => [value]));
  const demandRange = ss.getRangeByName('СкладТоваров_Спрос');
  demandRange.setValues(resourceDemand.map(value => [value]));

  // Запись журналов событий
  if (eventLog.length > 0) {
    const eventLogSheet = ss.getSheetByName('Журнал событий');
    const lastRow = eventLogSheet.getLastRow();
    eventLogSheet.getRange(lastRow + 1, 1, eventLog.length, 2).setValues(eventLog);
  }

  // Обновление данных провинций
  const provincesRange = ss.getRangeByName('Провинции_ОсновнаяИнформация');
  const updatedProvincesValues = provincesData.map(province => {
    if (province) {
      return [JSON.stringify(province)];
    } else {
      return [''];
    }
  });
  provincesRange.setValues(updatedProvincesValues);

  // Запись метрик государства
  const stateMetricsJSON = JSON.stringify(stateMetrics);
  ss.getRangeByName('Переменные_СтатистикаГосударства').setValue(stateMetricsJSON);
}

// Сброс доходов и расходов постройки.
function resetBuilding(building) {
  building.expenses = 0;
  building.incomes = 0;
  building.status = 'Активная';
}

// Проверка соответствия критериев постройки.
function checkBuildingCriteria(buildingTemplate, province, stateData, stateName, building, provinceMessages, attributesData) {
  // Проверка критериев провинции
  const provinceCriteriaMet = checkCriteria(buildingTemplate, province, 'province');
  if (!provinceCriteriaMet.success) {
    building.status = 'Неактивная';
    const reasons = provinceCriteriaMet.reasons.join('; ');
    provinceMessages.push(`Провинция "${province.province_id}" не подходит для здания "${building.name}". Причины: ${reasons}`);
    return false;
  }

  // Проверка критериев государства
  const stateCriteriaMet = checkCriteria(buildingTemplate, stateData, 'state');
  if (!stateCriteriaMet.success) {
    building.status = 'Неактивная';
    const reasons = stateCriteriaMet.reasons.join('; ');
    provinceMessages.push(`Государство "${stateName}" не подходит для здания "${building.name}". Владелец постройки "${building.building_owner}". Причины: ${reasons}`);
    return false;
  }

  // Проверка атрибутов постройки
  const attributeCheckResult = checkBuildingAttributeRequirements(buildingTemplate, province, attributesData);
  if (!attributeCheckResult.success) {
    building.status = 'Неактивная';
    const reasons = attributeCheckResult.reasons.join('; ');
    provinceMessages.push(`Провинция "${province.province_id}" не соответствует атрибутам для постройки "${building.name}". Причины: ${reasons}`);
    return false;
  }

  return true;
}

// Назначение рабочих для постройки.
function assignWorkers(buildingTemplate, province, stateMetrics, averageSalary, building, provinceMessages) {
  const requiredWorkers = buildingTemplate.required_workers || 0;
  const freeWorkers = province.available_workers - province.occupied_workers;
  stateMetrics.workers_required += requiredWorkers;

  if (freeWorkers >= requiredWorkers) {
    province.occupied_workers += requiredWorkers;
    stateMetrics.workers_occupied += requiredWorkers;
    building.expenses += requiredWorkers * averageSalary;
    return true;
  } else {
    building.status = 'Неактивная';
    provinceMessages.push(`Не хватает рабочей силы для постройки "${building.name}" в провинции "${province.province_id}". Необходимо ${requiredWorkers}, доступно ${freeWorkers}. Постройка получит статус "Неактивная".`);
    return false;
  }
}

// Назначение агрокультурных земель для постройки.
function assignAgriculturalLand(buildingTemplate, freeAgriculturalLand, usedAgriculturalLand, building, provinceMessages) {
  const requiredAgriculturalLand = buildingTemplate.required_agricultural_land || 0;

  if (freeAgriculturalLand < requiredAgriculturalLand) {
    building.status = 'Неактивная';
    provinceMessages.push(`Недостаточно агрокультурных земель для постройки "${building.name}" в провинции "${building.province_id}". Необходимо ${requiredAgriculturalLand}, доступно ${freeAgriculturalLand}. Постройка получит статус "Неактивная".`);
    return false;
  }

  usedAgriculturalLand += requiredAgriculturalLand;
  freeAgriculturalLand -= requiredAgriculturalLand;
  return true;
}

// Обработка потребления ресурсов зданием.
function processBuildingResources(building, buildingTemplate, province, resourceIndexMap, resourceStock, resourcePrices, consumptionEfficiency, provinceMessages, resourceDemand, resourceSupplyTotal) {
  const consumption = buildingTemplate.consumption || {};
  let consumptionPossible = true;
  let consumptionCost = 0;
  const missingResources = [];

  for (const resource in consumption) {
    const requiredAmount = consumption[resource] * consumptionEfficiency;
    const index = resourceIndexMap[resource];
    if (index === undefined) continue;

    resourceDemand[index] += requiredAmount;

    if (resourceStock[index] >= requiredAmount) {
      resourceStock[index] -= requiredAmount;
      consumptionCost += requiredAmount * resourcePrices[index];
    } else {
      consumptionPossible = false;
      missingResources.push(`${resource}: необходимо ${requiredAmount}, доступно ${resourceStock[index] || 0}`);
    }
  }

  if (!consumptionPossible) {
    building.status = 'Неактивная';
    provinceMessages.push(`Недостаточно ресурсов для постройки "${building.name}" в провинции "${province.province_id}". ${missingResources.join('; ')}`);

    return false;
  } else {
    building.expenses += consumptionCost;
    return true;
  }
}

// Обработка производства ресурсов зданием.
function processResourceProduction(building, buildingTemplate, resourceIndexMap, resourceStock, stateMetrics, resourcePrices, productionEfficiency, resourceDemand, resourceSupplyTotal) {
  const production = buildingTemplate.production || {};
  let productionIncome = 0;

  for (const resource in production) {
    const producedAmount = production[resource] * productionEfficiency;
    const index = resourceIndexMap[resource];
    if (index === undefined) continue;

    resourceSupplyTotal[index] += producedAmount;
    resourceStock[index] += producedAmount;
    productionIncome += producedAmount * resourcePrices[index];
  }

  building.incomes += productionIncome;
  return;
}

// Обработка корпоративного налога.
function processCorporateTax(building, stateName, corporateTax, stateMetrics) {
  if (building.building_owner !== stateName && building.status === 'Активная') {
    const taxAmount = building.incomes * corporateTax;
    building.expenses += taxAmount;

    stateMetrics.corporate_tax_income += taxAmount;
  }
}

// Обновление атрибутов на основе активных построек.
function updateAttributes(building, buildingTemplate, provinceAttributes, stateAttributes) {
  // Обработка атрибутов активной постройки для провинции
  if (building.status === 'Активная' && buildingTemplate.province_attributes) {
    for (const attributeKey in buildingTemplate.province_attributes) {
      const attributeValue = buildingTemplate.province_attributes[attributeKey];

      // Суммируем атрибуты в provinceAttributes
      if (provinceAttributes.hasOwnProperty(attributeKey)) {
        provinceAttributes[attributeKey] += attributeValue;
      } else {
        provinceAttributes[attributeKey] = attributeValue;
      }
    }
  }

  // Обработка атрибутов активной постройки для государства
  if (building.status === 'Активная' && buildingTemplate.state_attributes) {
    for (const attributeKey in buildingTemplate.state_attributes) {
      const attributeValue = buildingTemplate.state_attributes[attributeKey];

      // Суммируем атрибуты в stateAttributes
      if (stateAttributes.hasOwnProperty(attributeKey)) {
        stateAttributes[attributeKey] += attributeValue;
      } else {
        stateAttributes[attributeKey] = attributeValue;
      }
    }
  }
}

// Обработка самоуничтожения построек.
function handleSelfDestruction(province, eventLog) {
  if (province.buildings && province.buildings.length > 0) {
    // Используем копию массива зданий для безопасного удаления элементов во время итерации
    const buildingsCopy = [...province.buildings];
    buildingsCopy.forEach(building => {
      processSelfDestruction(building, province, eventLog);
    });
  }
}

// Функция обработки добычи ресурсов для активной постройки
function processResourceExtraction(building, buildingTemplate, province, resourceIndexMap, resourceStock, resourcePrices, extractionCoefficient, provinceMessages, resourceDemand, resourceSupplyTotal) {
  const resourceExtraction = buildingTemplate.resource_extraction;

  // Проверяем, существует ли resource_extraction и не пустой ли он
  if (!resourceExtraction || Object.keys(resourceExtraction).length === 0) {
    return; // Нет ресурсов для добычи, выходим из функции
  }

  const provinceResources = province.resources || [];

  for (const resourceName in resourceExtraction) {
    const baseExtractionAmount = resourceExtraction[resourceName];
    const extractionAmount = baseExtractionAmount * extractionCoefficient;

    // Поиск ресурса в провинции
    const resourceEntryIndex = provinceResources.findIndex(res => res.startsWith(resourceName + ":"));
    if (resourceEntryIndex === -1) {
      // Ресурс не найден
      provinceMessages.push(`Постройка "${building.name}" не находит запасы необходимого ресурса "${resourceName}". Добыча будет остановлена.`);
      continue; // Пропускаем обработку этого ресурса
    }

    // Парсим количество ресурса
    let [resName, resQuantityStr] = provinceResources[resourceEntryIndex].split(":");
    let resQuantity = parseFloat(resQuantityStr) || 0;

    // Проверка достаточности ресурса
    if (resQuantity > extractionAmount) {
      // Достаточно ресурса для извлечения
      provinceResources[resourceEntryIndex] = `${resName}:${resQuantity - extractionAmount}`;
      // Добавляем на склад
      const stockIndex = resourceIndexMap[resName];
      if (stockIndex !== undefined) {
        resourceStock[stockIndex] += extractionAmount;
      } else {
        // Ресурс не найден в списке ресурсов склада
        provinceMessages.push(`Тип ресурса "${resName}" не найден в складе.`);
        continue;
      }

      // Добавляем добытые ресурсы в предложение
      resourceSupplyTotal[stockIndex] += extractionAmount;

      // Рассчитываем доход от добычи
      const resourcePrice = resourcePrices[stockIndex] || 0;
      const incomeFromExtraction = extractionAmount * resourcePrice;
      building.incomes += incomeFromExtraction;

      // Рассчитываем количество циклов до истощения
      const remainingQuantity = resQuantity - extractionAmount;
      const remainingCycles = extractionAmount > 0 ? Math.floor(remainingQuantity / extractionAmount) : 0;
      if (remainingCycles <= 5) {
        provinceMessages.push(`Постройка "${building.name}" истощает запасы ресурса "${resName}". Добыча будет остановлена через ${remainingCycles} ходов.`);
      }
    } else if (resQuantity > 0 && resQuantity <= extractionAmount) {
      // Остаток ресурса меньше или равен extractionAmount
      // Добавляем остаток на склад
      const stockIndex = resourceIndexMap[resName];
      if (stockIndex !== undefined) {
        resourceStock[stockIndex] += resQuantity;
        resourceSupplyTotal[stockIndex] += resQuantity;
      } else {
        // Ресурс не найден в списке ресурсов склада
        provinceMessages.push(`Тип ресурса "${resName}" не найден в складе.`);
      }
      // Добавляем доход от добычи остатка
      const resourcePrice = resourcePrices[stockIndex] || 0;
      const incomeFromExtraction = resQuantity * resourcePrice;
      building.incomes += incomeFromExtraction;

      // Удаляем ресурс из провинции
      provinceResources.splice(resourceEntryIndex, 1);
      // Записываем событие
      provinceMessages.push(`Постройка "${building.name}" истощила запасы ресурса "${resName}". Добыча будет остановлена.`);
    } else {
      // Нет ресурса для добычи
      provinceMessages.push(`Постройка "${building.name}" не находит запасы необходимого ресурса "${resName}". Добыча будет остановлена.`);
    }
  }

  // Обновляем ресурсы провинции
  province.resources = provinceResources;
}

// Функция проверки и ограничения значений атрибутов провинций.
function enforceProvinceAttributeLimits(provincesData, stateName, eventLog) {
    // Шаг 1: Определение лимитов атрибутов провинций
    const attributeLimits = {
      "transport_infrastructure": {
        hasLimit: true,
        min: 0,
        max: 100,
        log: false, // Параметр отвечающий за вывод сообщения в журнал событий
        message: 'Провинция "{province_id}": Атрибут "{attribute}" скорректирован с {oldValue} до {newValue} из-за нарушения ограничения.'
      }
      // Добавьте другие атрибуты по необходимости
    };

    // Шаг 2: Проверка и корректировка атрибутов провинций
    provincesData.forEach(province => {
      if (!province || province.owner !== stateName) return; // Пропускаем провинции других стран

      if (!province.province_attributes) {
        province.province_attributes = {};
      }

      let attributesChanged = false;
      let provinceMessages = [];

      for (const attribute in attributeLimits) {
        const limit = attributeLimits[attribute];
        if (!limit.hasLimit) continue;

        if (province.province_attributes.hasOwnProperty(attribute)) {
          let value = province.province_attributes[attribute];
          const { min, max, log, message } = limit;
          let adjusted = false;
          let oldValue = value;
          let newValue = value;

          // Проверка на минимальное значение
          if (min !== null && value < min) {
            newValue = min;
            adjusted = true;
          }

          // Проверка на максимальное значение
          if (max !== null && value > max) {
            newValue = max;
            adjusted = true;
          }

          if (adjusted) {
            province.province_attributes[attribute] = newValue;
            attributesChanged = true;

            if (log && message) {
              const formattedMessage = message
                .replace('{province_id}', province.province_id || 'Неизвестен')
                .replace('{attribute}', attribute)
                .replace('{oldValue}', oldValue)
                .replace('{newValue}', newValue);
              provinceMessages.push(formattedMessage);
            }
          }
        }
      }

      if (attributesChanged && provinceMessages.length > 0) {
        eventLog.push([provinceMessages.join(' '), 'Уведомление']);
      }
    });
}

// Функция проверки и ограничения значений атрибутов государства.
function enforceStateAttributeLimits(attributesData, eventLog) {
    // Шаг 1: Определение лимитов атрибутов государства
    const stateAttributeLimits = {
      "science_points": {
        hasLimit: true,
        min: 0,
        max: 10000,
        log: true, // Параметр отвечающий за вывод сообщения в журнал событий
        message: 'Количество очков науки({attribute}) было изменено с {oldValue} на {newValue} из-за нарушения лимита накопления.'
      },
      "culture_points": {
        hasLimit: true,
        min: 0,
        max: 10000,
        log: true,
        message: 'Количество очков культуры({attribute}) было изменено с {oldValue} на {newValue} из-за нарушения лимита накопления.'
      },
      "religion_points": {
        hasLimit: true,
        min: 0,
        max: 10000,
        log: true,
        message: 'Количество очков религии({attribute}) было изменено с {oldValue} на {newValue} из-за нарушения лимита накопления.'
      }
      // Добавьте другие атрибуты по необходимости
    };

    // Шаг 2: Проверка и корректировка атрибутов государства
    for (const attribute in stateAttributeLimits) {
      const limit = stateAttributeLimits[attribute];
      if (!limit.hasLimit) continue;

      if (attributesData.hasOwnProperty(attribute)) {
        let value = attributesData[attribute];
        const { min, max, log, message } = limit;
        let adjusted = false;
        let oldValue = value;
        let newValue = value;

        // Проверка на минимальное значение
        if (min !== null && value < min) {
          newValue = min;
          adjusted = true;
        }

        // Проверка на максимальное значение
        if (max !== null && value > max) {
          newValue = max;
          adjusted = true;
        }

        if (adjusted) {
          attributesData[attribute] = newValue;

          if (log && message) {
            const formattedMessage = message
              .replace('{attribute}', attribute)
              .replace('{oldValue}', oldValue)
              .replace('{newValue}', newValue);
            eventLog.push([formattedMessage, 'ВНИМАНИЕ']);
          }
        }
      }
    }
}

// Функция проверки и применения лимитов построек.
function enforceBuildingLimits(buildingTemplatesMap, targetProvinces, stateName, eventLog) {
  for (const buildingName in buildingTemplatesMap) {
    const template = buildingTemplatesMap[buildingName];
    if (template.building_limit !== undefined && template.building_limit > 0) {
      const limit = template.building_limit;
      // Собираем все здания данного типа, принадлежащие государству
      let buildingsList = [];

      targetProvinces.forEach((province, provinceIndex) => {
        if (province.buildings) {
          province.buildings.forEach((building, buildingIndex) => {
            if (building.name === buildingName) {
              buildingsList.push({ provinceIndex, buildingIndex, building });
            }
          });
        }
      });

      const currentCount = buildingsList.length;

      if (currentCount > limit) {
        const excess = currentCount - limit;
        for (let i = 0; i < excess; i++) {
          const buildingToRemove = buildingsList.pop(); // Удаляем последние постройки
          const { provinceIndex, buildingIndex, building } = buildingToRemove;
          const province = targetProvinces[provinceIndex];

          if (!province) { // Эта проверка теперь избыточна, но оставлена на случай изменений
            continue;
          }

          // Удаляем постройку из провинции
          province.buildings.splice(buildingIndex, 1);

          // Записываем сообщение в журнал событий
          eventLog.push([
            `Лимит построек типа "${buildingName}" для государства превышен. Постройка удалена из провинции "${province.province_id}".`,
            'ВНИМАНИЕ'
          ]);
        }
      }
    }
  }
}

// Функция проверки и применения лимитов построек для каждой провинции.
function enforceProvinceBuildingLimits(buildingTemplatesMap, provincesData, stateName, eventLog) {
  provincesData.forEach(province => {
    if (!province || province.owner !== stateName || !province.buildings) return;

    // Создаем карту для подсчета построек по типам
    const buildingCountMap = {};

    province.buildings.forEach(building => {
      if (building.name) {
        buildingCountMap[building.name] = (buildingCountMap[building.name] || 0) + 1;
      }
    });

    // Проверяем каждый тип постройки на превышение лимита
    for (const [buildingName, count] of Object.entries(buildingCountMap)) {
      const template = buildingTemplatesMap[buildingName];
      if (template && template.province_limit !== undefined && count > template.province_limit) {
        const excess = count - template.province_limit;

        // Находим избыточные постройки для удаления
        const buildingsToRemove = province.buildings.filter(b => b.name === buildingName).slice(-excess);

        buildingsToRemove.forEach(building => {
          const buildingIndex = province.buildings.indexOf(building);
          if (buildingIndex > -1) {
            province.buildings.splice(buildingIndex, 1);

            // Записываем сообщение в журнал событий
            eventLog.push([
              `Лимит построек типа "${buildingName}" для провинции "${province.province_id}" превышен. Постройка была удалена.`,
              'ВНИМАНИЕ'
            ]);
          }
        });
      }
    }
  });
}

// Чтение шаблонов построек.
function readBuildingTemplates(ss) {
  const buildingTemplatesRange = ss.getRangeByName('Постройки_Шаблоны');
  const buildingTemplatesValues = buildingTemplatesRange.getValues();
  const buildingTemplates = buildingTemplatesValues.map(row => {
    if (row[0]) {
      try {
        return JSON.parse(row[0]);
      } catch (e) {
        Logger.log(`Ошибка парсинга шаблона постройки: ${e}`);
        return null;
      }
    } else {
      return null;
    }
  });

  const buildingTemplatesMap = {};
  buildingTemplates.forEach(template => {
    if (template && template.name) {
      buildingTemplatesMap[template.name] = template;
    }
  });
  return buildingTemplatesMap;
}

// Функция для чтения данных из именованного диапазона, который может содержать несколько ячеек
function readDataFromRange(rangeName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const range = ss.getRangeByName(rangeName);
  if (!range) {
    Logger.log(`Диапазон ${rangeName} не найден.`);
    return [];
  }

  const values = range.getValues();
  let result = [];

  for (let i = 0; i < values.length; i++) {
    for (let j = 0; j < values[i].length; j++) {
      const cellValue = values[i][j];

      if (cellValue) {
        let parsedValue;
        try {
          parsedValue = JSON.parse(cellValue);

          if (Array.isArray(parsedValue)) {
            result = result.concat(parsedValue);
          } else {
            result.push(parsedValue);
          }
        } catch (e) {
          // Если не удалось распарсить как JSON, добавляем значение напрямую
          result.push(cellValue);
        }
      }
    }
  }

  return result;
}

// Чтение изученных технологий
function readStateTechnologiesGeneral(rangeName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const range = ss.getRangeByName(rangeName);
  if (!range) {
    Logger.log(`Диапазон ${rangeName} не найден.`);
    return [];
  }

  const values = range.getValues();
  let result = [];

  for (let i = 0; i < values.length; i++) {
    for (let j = 0; j < values[i].length; j++) {
      const cellValue = values[i][j];

      if (cellValue) {
        let techObject;
        try {
          techObject = JSON.parse(cellValue);

          if (techObject.status === 'Изучена' && techObject.name) {
            result.push(techObject.name);
          }
        } catch (e) {
          Logger.log(`Ошибка парсинга JSON в ячейке (${i + 1}, ${j + 1}): ${e}`);
        }
      }
    }
  }

  return result;
}

// Чтение принятых законов
function readStateLawsGeneral(rangeName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const range = ss.getRangeByName(rangeName);
  if (!range) {
    Logger.log(`Диапазон ${rangeName} не найден.`);
    return [];
  }

  const values = range.getValues();
  let result = [];

  for (let i = 0; i < values.length; i++) {
    for (let j = 0; j < values[i].length; j++) {
      const cellValue = values[i][j];

      if (cellValue) {
        let lawObject;
        try {
          lawObject = JSON.parse(cellValue);

          if (lawObject.status === 'Принят' && lawObject.name) {
            result.push(lawObject.name);
          }
        } catch (e) {
          Logger.log(`Ошибка парсинга JSON в ячейке (${i + 1}, ${j + 1}): ${e}`);
        }
      }
    }
  }

  return result;
}

// Сброс определённых атрибутов провинции.
function resetProvinceAttributes(provinceAttributes) {
  const provinceAttributesResetMap = {
    'transport_infrastructure': true,
    // Добавьте другие атрибуты по необходимости
  };

  for (const attributeKey in provinceAttributesResetMap) {
    if (provinceAttributesResetMap[attributeKey]) {
      provinceAttributes[attributeKey] = 0;
    }
  }
}

// Применение модификаторов к зданиям
function applyBuildingModifiers(buildingTemplate, stateModifiers) {
  const appliedModifiers = {
    productionEfficiency: 0,
    extractionCoefficient: 0,
    consumptionEfficiency: 0
  };

  if (buildingTemplate.modifiers) {
    // Пример: для production_efficiency
    if (buildingTemplate.modifiers.production_efficiency) {
      appliedModifiers.productionEfficiency = getSummedModifiers(
        buildingTemplate.modifiers.production_efficiency,
        stateModifiers
      );
    }

    // Пример: для extraction_coefficient
    if (buildingTemplate.modifiers.extraction_coefficient) {
      appliedModifiers.extractionCoefficient = getSummedModifiers(
        buildingTemplate.modifiers.extraction_coefficient,
        stateModifiers
      );
    }

    // Пример: для consumption_efficiency (в шаблоне была опечатка, исправил на правильное написание)
    if (buildingTemplate.modifiers.consumption_efficiency) {
      appliedModifiers.consumptionEfficiency = getSummedModifiers(
        buildingTemplate.modifiers.consumption_efficiency,
        stateModifiers
      );
    }
  }

  return appliedModifiers;
}

// Функция для суммирования модификаторов
function getSummedModifiers(modifiersArray, stateModifiers) {
  let summedModifier = 0;

  modifiersArray.forEach(modifierObj => {
    const modifierName = modifierObj.name;
    const modifierValue = stateModifiers[modifierName] || 0; // Если модификатор не найден, используем значение 0

    summedModifier += modifierValue; // Суммируем модификаторы
  });

  return summedModifier;
}

// Функция проверки критериев
function checkCriteria(template, dataObject, type) {
  const criteriaList = getCriteriaList(type);
  let allSuccess = true;
  let reasons = [];

  for (const criterion of criteriaList) {
    const key = criterion.key;
    const attribute = criterion.attribute;
    const description = criterion.description;
    const dataType = criterion.dataType;
    const templateCriterion = template[key];

    if (templateCriterion) {
      let dataValue = dataObject[attribute];

      // Инициализация значения по умолчанию, если оно отсутствует
      if (dataValue === undefined || dataValue === null) {
        if (dataType === 'text') {
          dataValue = [];
        } else if (dataType === 'number') {
          dataValue = 0;
        }
      }

      // Специальная обработка для ресурсов в провинции
      if (attribute === 'resources') {
        if (Array.isArray(dataValue)) {
          dataValue = dataValue.map(res => res.split(':')[0]);
        } else {
          dataValue = [];
        }
      }

      const result = evaluateCondition(templateCriterion, dataValue, dataType);
      if (!result.success) {
        allSuccess = false;
        reasons.push(`${description}: ${result.reason}`);
      }
    }
  }

  if (allSuccess) {
    return { success: true };
  } else {
    return { success: false, reasons: reasons };
  }
}

// Получение списка критериев в зависимости от типа данных
function getCriteriaList(type) {
  if (type === 'province') {
    return [
      { key: 'required_province_cultures', attribute: 'cultures', description: 'Культуры', dataType: 'text' },
      { key: 'required_province_landscapes', attribute: 'landscapes', description: 'Ландшафты', dataType: 'text' },
      { key: 'required_province_religions', attribute: 'religions', description: 'Религии', dataType: 'text' },
      { key: 'required_province_races', attribute: 'races', description: 'Расы', dataType: 'text' },
      { key: 'required_province_climates', attribute: 'climates', description: 'Климат', dataType: 'text' },
      { key: 'required_province_resources', attribute: 'resources', description: 'Ресурсы', dataType: 'text' },
      { key: 'required_province_continents', attribute: 'continents', description: 'Континенты', dataType: 'text' },
      { key: 'required_province_planets', attribute: 'planets', description: 'Планеты', dataType: 'text' },
      { key: 'required_province_radiation', attribute: 'radiation_level', description: 'Уровень радиации', dataType: 'number' },
      { key: 'required_province_pollution', attribute: 'pollution_level', description: 'Уровень загрязнения', dataType: 'number' },
    ];
  } else if (type === 'state') {
    return [
      { key: 'required_state_cultures', attribute: 'cultures', description: 'Культуры государства', dataType: 'text' },
      { key: 'required_state_religions', attribute: 'religions', description: 'Религии государства', dataType: 'text' },
      { key: 'required_state_races', attribute: 'races', description: 'Расы государства', dataType: 'text' },
      { key: 'required_state_technologies', attribute: 'technologies', description: 'Технологии', dataType: 'text' },
      { key: 'required_state_laws', attribute: 'laws', description: 'Законы', dataType: 'text' },
      { key: 'required_state_government', attribute: 'government_type', description: 'Тип правительства', dataType: 'text' },
      { key: 'required_state_stability', attribute: 'stability', description: 'Социальная стабильность', dataType: 'number' },
    ];
  }
  return [];
}

// Оценка условия для критериев
function evaluateCondition(condition, dataValue, dataType) {
  if (typeof condition === 'object' && !Array.isArray(condition)) {
    for (const operator in condition) {
      const operands = condition[operator];
      switch (operator) {
        case 'AND': {
          let reasons = [];
          let allSuccess = true;
          for (const op of operands) {
            const result = evaluateCondition(op, dataValue, dataType);
            if (!result.success) {
              allSuccess = false;
              reasons.push(result.reason);
            }
          }
          return allSuccess
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось ${describeConditionProvince({ AND: operands })}, но найдено ${formatDataValue(dataValue)}. Несоответствия: ${reasons.join('; ')}`,
              };
        }
        case 'OR': {
          let anySuccess = false;
          let reasons = [];
          for (const op of operands) {
            const result = evaluateCondition(op, dataValue, dataType);
            if (result.success) {
              anySuccess = true;
              break;
            } else {
              reasons.push(result.reason);
            }
          }
          return anySuccess
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось ${describeConditionProvince({ OR: operands })}, но найдено ${formatDataValue(dataValue)}. Причины: ${reasons.join('; ')}`,
              };
        }
        case 'NOT': {
          const result = evaluateCondition(operands[0], dataValue, dataType);
          return !result.success
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось ${describeConditionProvince({ NOT: operands })}, но найдено ${formatDataValue(dataValue)}`,
              };
        }
        case 'XOR': {
          let trueCount = 0;
          for (const op of operands) {
            const result = evaluateCondition(op, dataValue, dataType);
            if (result.success) {
              trueCount++;
            }
          }
          return trueCount === 1
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось ${describeConditionProvince({ XOR: operands })}, но найдено ${formatDataValue(dataValue)}`,
              };
        }
        case 'GREATER_THAN': {
          return dataValue > operands
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось значение больше ${operands}, но значение равно ${dataValue}`,
              };
        }
        case 'LESS_THAN': {
          return dataValue < operands
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось значение меньше ${operands}, но значение равно ${dataValue}`,
              };
        }
        case 'EQUALS': {
          return dataValue == operands
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось значение равно ${operands}, но значение равно ${dataValue}`,
              };
        }
        case 'NOT_EQUALS': {
          return dataValue != operands
            ? { success: true }
            : {
                success: false,
                reason: `Ожидалось значение не равно ${operands}, но значение равно ${dataValue}`,
              };
        }
        // Добавьте другие операторы по необходимости
        default:
          return { success: true };
      }
    }
  } else {
    // Базовый случай: сравнение значений
    if (dataType === 'text') {
      if (Array.isArray(dataValue)) {
        return dataValue.includes(condition)
          ? { success: true }
          : {
              success: false,
              reason: `Ожидалось значение "${condition}", но найдено ${formatDataValue(dataValue)}`,
            };
      } else {
        return dataValue == condition
          ? { success: true }
          : {
              success: false,
              reason: `Ожидалось значение "${condition}", но найдено "${dataValue}"`,
            };
      }
    } else if (dataType === 'number') {
      return dataValue == condition
        ? { success: true }
        : {
            success: false,
            reason: `Ожидалось значение ${condition}, но найдено ${dataValue}`,
          };
    }
  }
  return { success: true };
}

// Описание условия для логирования
function describeConditionProvince(condition) {
  if (typeof condition === 'string') {
    return `"${condition}"`;
  }

  if (Object.keys(condition).length === 0) {
    return ''; // Возвращаем пустую строку для пустого условия
  }

  if (condition.AND) {
    return `(${condition.AND.map(c => describeConditionProvince(c)).join(' и ')})`;
  }

  if (condition.OR) {
    return `(${condition.OR.map(c => describeConditionProvince(c)).join(' или ')})`;
  }

  if (condition.NOT) {
    return `не должно быть следующих значений: ${condition.NOT.map(c => describeConditionProvince(c)).join(' и ')}`;
  }

  if (condition.XOR) {
    return `только одно из следующих значений: ${condition.XOR.map(c => describeConditionProvince(c)).join(' или ')}`;
  }

  if (condition.GREATER_THAN !== undefined) {
    return `значение больше ${condition.GREATER_THAN}`;
  }

  if (condition.LESS_THAN !== undefined) {
    return `значение меньше ${condition.LESS_THAN}`;
  }

  if (condition.EQUALS !== undefined) {
    return `значение равно ${condition.EQUALS}`;
  }

  if (condition.NOT_EQUALS !== undefined) {
    return `значение не равно ${condition.NOT_EQUALS}`;
  }

  // Добавьте обработку других операторов при необходимости

  return 'неизвестное условие';
}

// Функция проверки соответствия атрибутов провинции и государства требованиям постройки.
function checkBuildingAttributeRequirements(buildingTemplate, province, stateAttributes) {
  let allSuccess = true;
  let reasons = [];

  // Проверка атрибутов провинции
  if (buildingTemplate.required_province_attributes && Object.keys(buildingTemplate.required_province_attributes).length > 0) {
    for (const attribute in buildingTemplate.required_province_attributes) {
      const { min, max } = buildingTemplate.required_province_attributes[attribute];
      const provinceValue = province.province_attributes[attribute] || 0;

      if (min !== undefined && provinceValue < min) {
        allSuccess = false;
        reasons.push(`Атрибут провинции "${attribute}" меньше минимального (${provinceValue} < ${min})`);
      }
      if (max !== undefined && provinceValue > max) {
        allSuccess = false;
        reasons.push(`Атрибут провинции "${attribute}" больше максимального (${provinceValue} > ${max})`);
      }
    }
  }

  // Проверка атрибутов государства
  if (buildingTemplate.required_state_attributes && Object.keys(buildingTemplate.required_state_attributes).length > 0) {
    for (const attribute in buildingTemplate.required_state_attributes) {
      const { min, max } = buildingTemplate.required_state_attributes[attribute];
      const stateValue = stateAttributes[attribute] || 0;

      if (min !== undefined && stateValue < min) {
        allSuccess = false;
        reasons.push(`Атрибут государства "${attribute}" меньше минимального (${stateValue} < ${min})`);
      }
      if (max !== undefined && stateValue > max) {
        allSuccess = false;
        reasons.push(`Атрибут государства "${attribute}" больше максимального (${stateValue} > ${max})`);
      }
    }
  }

  return {
    success: allSuccess,
    reasons: reasons
  };
}

// Обработка самоуничтожения построек
function processSelfDestruction(building, province, eventLog) {
  if (!building.hasOwnProperty('self_destruction')) {
    // Если ключ отсутствует, инициализируем его значением 10
    building.self_destruction = 10;
  }

  if (building.status === 'Активная') {
    building.self_destruction = 10;
  } else if (building.status === 'Неактивная') {
    building.self_destruction = Math.max(building.self_destruction - 1, 0);

    if (building.self_destruction <= 3 && building.self_destruction > 0) {
      eventLog.push([
        `Здание "${building.name}" в провинции "${province.province_id}" будет снесено через ${building.self_destruction} ходов по причине длительной неактивности.`,
        'Уведомление'
      ]);
    }

    if (building.self_destruction === 0) {
      // Удаляем здание из провинции
      const buildingIndex = province.buildings.indexOf(building);
      if (buildingIndex > -1) {
        province.buildings.splice(buildingIndex, 1);
        eventLog.push([
          `Здание "${building.name}" в провинции "${province.province_id}" было снесено из-за длительной неактивности.`,
          'Уведомление'
        ]);
      }
    }
  }
}

// Форматирование значения данных для логирования
function formatDataValue(dataValue) {
  if (Array.isArray(dataValue)) {
    return `[${dataValue.join(', ')}]`;
  }
  return dataValue;
}